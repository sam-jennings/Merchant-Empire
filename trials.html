<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Archmage Ascension - The Ascension Trial</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cormorant+Garamond:wght@300;400;500;600&display=swap" rel="stylesheet">

  <!-- Archmage theme (dark-only) -->
  <link rel="stylesheet" href="archmage-theme.css" />

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Load configuration (colors/theme optional; app will not rely on it) -->
  <script src="config.js"></script>

  <style>
    /* Page-specific styles only (shared styles are in archmage-theme.css) */
    .app-shell { padding-top: 1rem; padding-bottom: 2rem; }

    /* Make spell type buttons equal width */
    .spell-actions {
      display: grid !important;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 0.75rem;
    }
    .spell-actions button {
      width: 100%;
      white-space: normal;
      min-height: 48px;
      padding: 0.75rem 1rem;
    }

    .icon-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 48px;
      height: 48px;
      min-width: 48px;
      border-radius: 10px;
      border: 2px solid rgba(239, 68, 68, 0.6);
      background: rgba(239, 68, 68, 0.1);
      color: #ef4444;
      cursor: pointer;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }
    .icon-btn:hover {
      border-color: #ef4444;
      background: rgba(239, 68, 68, 0.2);
      color: #ff5555;
      transform: translateY(-1px);
    }
    .icon-btn svg {
      display: block;
      width: 24px;
      height: 24px;
      stroke: currentColor;
      fill: none;
    }

    /* Spell card header layout */
    .spell-card .row.between {
      gap: 1rem;
      align-items: flex-start;
    }

    /* Better mobile input sizing */
    input[type="number"],
    select {
      width: 100%;
      font-size: 1rem;
      padding: 0.75rem;
    }

    /* Ensure spell cards stack properly on mobile */
    @media (max-width: 520px) {
      .spell-actions {
        grid-template-columns: 1fr;
      }

      .spell-card .row.between {
        flex-direction: row !important;
        justify-content: space-between;
        align-items: flex-start;
      }

      .icon-btn {
        margin-top: 0.25rem;
      }

      input[type="number"],
      select {
        padding: 0.9rem;
        font-size: 1.05rem;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useState } = React;
    const config = (typeof GameConfig !== 'undefined') ? GameConfig : {};

    // -------------------------------------------------------------------------
    // Safe config helpers (so config.colors / theme blocks can be deleted)
    // -------------------------------------------------------------------------
    const safeArray = (v) => Array.isArray(v) ? v : [];
    const safeObj = (v) => (v && typeof v === 'object') ? v : {};

    const ELEMENTS = safeArray(config.elements);
    const DOMAINS = safeObj(config.domains);
    const SPELL_TYPES = safeArray(config.spellTypes);

    const calcPower = (size) => {
      if (typeof config.calculatePower === 'function') return config.calculatePower(size);
      // Fallback: matches the current config.js behaviour
      if (size <= 4) return size * 1;
      if (size <= 6) return Math.round(size * 1.5);
      return size * 2;
    };

    const getPowerBreakdown = (size) => {
      if (typeof config.getPowerBreakdown === 'function') return config.getPowerBreakdown(size, calcPower);
      const power = calcPower(size);
      if (size <= 4) return `${size} √ó 1 = ${power}`;
      if (size <= 6) return `${size} √ó 1.5 = ${power}`;
      return `${size} √ó 2 = ${power}`;
    };

    const TEXT = {
      gameName: config.gameName || 'Archmage Ascension',
      gameSubtitle: config.gameSubtitle || 'The Ascension Trial',
      pointsName: config.pointsName || 'Recognition Points',
      pointsAbbreviation: config.pointsAbbreviation || 'RP',

      playerNoun: (config.text && config.text.playerNoun) || 'Wizard',
      playerNounPlural: (config.text && config.text.playerNounPlural) || 'Wizards',
      addPlayerButton: (config.text && config.text.addPlayerButton) || 'Add Wizard',
      playerInputPlaceholder: (config.text && config.text.playerInputPlaceholder) || 'Wizard name',
      startGameButton: (config.text && config.text.startGameButton) || 'Start Ascension Trial',
      startGameRequirement: (config.text && config.text.startGameRequirement) || 'All wizards must enter at least one power point',

      calculatorButton: (config.text && config.text.calculatorButton) || 'Spell Calculator',
      manualEntryActive: (config.text && config.text.manualEntryActive) || '‚úì Using Manual Entry',
      switchToManual: (config.text && config.text.switchToManual) || 'Switch to Manual Entry',

      setupHeader: (config.text && config.text.setupHeader) || 'Game Setup',
      setupSubheader: (config.text && config.text.setupSubheader) || 'Calculate or Enter Domain Power',
      addPlayersHeader: (config.text && config.text.addPlayersHeader) || 'Add Wizards',

      removeButton: (config.text && config.text.removeButton) || 'Remove',
    };

    const ELEMENT_SYMBOLS = Object.fromEntries(ELEMENTS.map(e => [e.name, e.symbol]));
    const DOMAIN_NAMES = Object.fromEntries(Object.entries(DOMAINS).map(([k, v]) => [k, v.name]));

    // -------------------------------------------------------------------------
    // Icons (inline SVGs)
    // -------------------------------------------------------------------------
    const CalculatorIcon = ({ size = 20 }) => (
      <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
      </svg>
    );

    const PlusIcon = ({ size = 18 }) => (
      <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
      </svg>
    );

    const TrashIcon = ({ size = 24 }) => (
      <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2.5} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
      </svg>
    );

    // -------------------------------------------------------------------------
    // Spell Calculator
    // -------------------------------------------------------------------------
    function SpellCalculator({ onDomainsCalculated }) {
      const [spells, setSpells] = useState([]);
      const [open, setOpen] = useState(true);

      const addSpell = (typeId) => {
        const defaultElementName = ELEMENTS[0]?.name || 'Earth';
        setSpells(prev => [
          ...prev,
          { id: Date.now() + Math.random(), type: typeId, element: defaultElementName, size: 3 }
        ]);
      };

      const updateSpell = (id, field, value) => {
        setSpells(prev => prev.map(s => (s.id === id ? { ...s, [field]: value } : s)));
      };

      const removeSpell = (id) => setSpells(prev => prev.filter(s => s.id !== id));

      const calculatedDomains = useMemo(() => {
        const domains = {};
        Object.keys(DOMAINS).forEach(k => (domains[k] = 0));

        for (const spell of spells) {
          const st = SPELL_TYPES.find(x => x.id === spell.type);
          if (st && typeof st.contributeToDomains === 'function') {
            st.contributeToDomains(spell, domains, calcPower);
          }
        }
        return domains;
      }, [spells]);

      useEffect(() => {
        onDomainsCalculated(calculatedDomains);
      }, [calculatedDomains]);

      const getSpellWarning = (spell) => {
        const st = SPELL_TYPES.find(x => x.id === spell.type);
        if (!st) return null;
        if (typeof st.warnUnder === 'number' && spell.size < st.warnUnder) {
          return `${st.name} needs at least ${st.warnUnder} components.`;
        }
        if (typeof st.warnOver === 'number' && spell.size > st.warnOver) {
          return `${st.name} typically doesn't exceed ${st.warnOver} components.`;
        }
        return null;
      };

      const getContributionText = (spell) => {
        const st = SPELL_TYPES.find(x => x.id === spell.type);
        if (!st || typeof st.contributeToDomains !== 'function') return '';
        const temp = {};
        Object.keys(DOMAINS).forEach(k => (temp[k] = 0));
        st.contributeToDomains(spell, temp, calcPower);
        const parts = [];
        for (const [k, v] of Object.entries(temp)) {
          if (v > 0) parts.push(`${DOMAIN_NAMES[k] || k}: +${v}`);
        }
        return parts.join(' ‚Ä¢ ');
      };

      return (
        <div className="stack">
          <button className="btn-primary" onClick={() => setOpen(o => !o)}>
            <span style={{ display: 'inline-flex', alignItems: 'center', gap: '0.6rem' }}>
              <CalculatorIcon />
              {open ? 'Hide' : 'Show'} {TEXT.calculatorButton}
            </span>
          </button>

          {open && (
            <div className="card">
              <div className="stack">
                <div>
                  <h4>Enter Your Spells</h4>
                  <p className="muted small">
                    Formula: {config.powerFormulaDescription || '3-4 √ó1, 5-6 √ó1.5, 7+ √ó2'}
                  </p>
                </div>

                <div className="spell-actions">
                  {SPELL_TYPES.map(st => (
                    <button key={st.id} className="btn-secondary" onClick={() => addSpell(st.id)}>
                      <span style={{ display: 'inline-flex', alignItems: 'center', gap: '0.5rem' }}>
                        <PlusIcon />
                        {st.emoji ? `${st.emoji} ` : ''}{st.name}
                      </span>
                    </button>
                  ))}
                </div>

                {spells.length === 0 ? (
                  <div className="info-box">
                    <p className="muted">No spells added yet. Use the buttons above.</p>
                  </div>
                ) : (
                  <div className="stack">
                    {spells.map(spell => {
                      const st = SPELL_TYPES.find(x => x.id === spell.type);
                      const needsElement = !!st?.requiresElement;
                      const warning = getSpellWarning(spell);
                      return (
                        <div key={spell.id} className="spell-card">
                          <div className="row between wrap">
                            <div>
                              <h5 style={{ marginBottom: '0.25rem' }}>{st?.emoji ? `${st.emoji} ` : ''}{st?.name || spell.type}</h5>
                              <div className="pill" title="Power breakdown">
                                {getPowerBreakdown(spell.size)}
                              </div>
                            </div>
                            <button className="icon-btn" onClick={() => removeSpell(spell.id)} title="Remove spell">
                              <TrashIcon />
                            </button>
                          </div>

                          {warning && (
                            <div className="warning-box" style={{ marginTop: '0.75rem' }}>
                              <strong>Warning:</strong> {warning}
                            </div>
                          )}

                          <div className="spell-grid" style={{ marginTop: '0.75rem' }}>
                            {needsElement && (
                              <div className="field">
                                <label>Element</label>
                                <select value={spell.element} onChange={(e) => updateSpell(spell.id, 'element', e.target.value)}>
                                  {ELEMENTS.map(el => (
                                    <option key={el.id} value={el.name}>{(el.symbol || '')} {el.name}</option>
                                  ))}
                                </select>
                              </div>
                            )}
                            <div className="field">
                              <label>Size</label>
                              <input
                                type="number"
                                min="0"
                                value={spell.size}
                                onChange={(e) => updateSpell(spell.id, 'size', Math.max(0, parseInt(e.target.value || '0', 10)))}
                              />
                            </div>
                          </div>

                          <div className="divider" />
                          <p className="muted small"><strong>Contributes:</strong> {getContributionText(spell) || '‚Äî'}</p>
                        </div>
                      );
                    })}
                  </div>
                )}

                <div className="power-summary">
                  <h4 className="text-center" style={{ marginBottom: '1rem' }}>Calculated Total Power</h4>
                  <div className="domain-grid">
                    {Object.entries(calculatedDomains).map(([k, v]) => (
                      <div key={k} className="domain-item">
                        <div className="row between">
                          <span className="muted small">{DOMAIN_NAMES[k] || k}</span>
                          <span className="highlight">{v}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    // -------------------------------------------------------------------------
    // Wizard Domain Setup
    // -------------------------------------------------------------------------
    function WizardDomainSetup({ wizard, updateWizardDomains, removeWizard }) {
      const [manual, setManual] = useState(false);
      const [manualDomains, setManualDomains] = useState(wizard.domains);

      const totalPower = Object.values(wizard.domains).reduce((s, v) => s + v, 0);

      const handleDomainsCalculated = (domains) => {
        if (!manual) updateWizardDomains(wizard.id, domains);
      };

      const handleManualChange = (domainKey, value) => {
        const next = { ...manualDomains, [domainKey]: Math.max(0, parseInt(value || '0', 10)) };
        setManualDomains(next);
        if (manual) updateWizardDomains(wizard.id, next);
      };

      const toggleManual = () => {
        setManual(prev => {
          const next = !prev;
          if (next) updateWizardDomains(wizard.id, manualDomains);
          return next;
        });
      };

      return (
        <div className="wizard-card">
          <div className="row between wrap">
            <div>
              <h3 style={{ marginBottom: '0.25rem' }}>{wizard.name}</h3>
              <span className="pill">Total Power: <strong>{totalPower}</strong></span>
            </div>
            <button className="btn-danger" onClick={() => removeWizard(wizard.id)}>
              {TEXT.removeButton}
            </button>
          </div>

          <div className="divider" />

          {!manual && (
            <SpellCalculator onDomainsCalculated={handleDomainsCalculated} />
          )}

          <div style={{ marginTop: '1rem' }}>
            <button className={manual ? 'btn-secondary' : 'btn-primary'} onClick={toggleManual}>
              {manual ? TEXT.manualEntryActive : TEXT.switchToManual}
            </button>
          </div>

          {manual && (
            <div className="card" style={{ marginTop: '1rem' }}>
              <h4 style={{ marginBottom: '0.75rem' }}>Manual Power Entry</h4>
              <div className="domain-grid">
                {Object.entries(DOMAIN_NAMES).map(([domainKey, domainName]) => (
                  <div key={domainKey} className="domain-item">
                    <div className="field">
                      <label>{domainName}</label>
                      <input
                        type="number"
                        min="0"
                        value={manualDomains[domainKey] ?? 0}
                        onChange={(e) => handleManualChange(domainKey, e.target.value)}
                      />
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          <div className="info-box" style={{ marginTop: '1rem' }}>
            <h4 style={{ marginBottom: '0.5rem' }}>Current Power (for Trial Phase)</h4>
            <div className="domain-grid">
              {Object.entries(wizard.domains).map(([k, v]) => (
                <div key={k} className="domain-item">
                  <div className="row between">
                    <span className="muted small">{DOMAIN_NAMES[k] || k}</span>
                    <span className="highlight">{v}</span>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      );
    }

    // -------------------------------------------------------------------------
    // Setup Phase
    // -------------------------------------------------------------------------
    function SetupPhase({ wizards, setWizards, startTrial }) {
      const [newWizardName, setNewWizardName] = useState('');

      const addWizard = () => {
        const name = newWizardName.trim();
        if (!name) return;
        const domains = Object.fromEntries(Object.keys(DOMAINS).map(k => [k, 0]));
        const wizard = {
          id: Date.now() + Math.random(),
          name,
          domains,
          allocations: {},
          locked: false
        };
        setWizards(prev => [wizard, ...prev]);
        setNewWizardName('');
      };

      const removeWizard = (wizardId) => {
        setWizards(prev => prev.filter(w => w.id !== wizardId));
      };

      const updateWizardDomains = (wizardId, domains) => {
        setWizards(prev => prev.map(w => (w.id === wizardId ? { ...w, domains } : w)));
      };

      const canStart = useMemo(() => {
        return wizards.length >= 2 && wizards.every(w => Object.values(w.domains).some(v => v > 0));
      }, [wizards]);

      return (
        <div className="card">
          <h2>{TEXT.setupHeader}</h2>
          <p className="subtitle" style={{ marginBottom: '1rem' }}>{TEXT.setupSubheader}</p>

          <div className="card" style={{ marginTop: '1rem' }}>
            <h4>{TEXT.addPlayersHeader}</h4>
            <div className="input-row" style={{ marginTop: '0.75rem' }}>
              <input
                type="text"
                value={newWizardName}
                onChange={(e) => setNewWizardName(e.target.value)}
                onKeyDown={(e) => { if (e.key === 'Enter') addWizard(); }}
                placeholder={TEXT.playerInputPlaceholder}
              />
              <button className="btn-primary" onClick={addWizard}>
                {TEXT.addPlayerButton}
              </button>
            </div>
            <p className="muted small" style={{ marginTop: '0.5rem' }}>
              Tip: On mobile, the button will stack under the input.
            </p>
          </div>

          {wizards.length > 0 && (
            <div style={{ marginTop: '1.25rem' }} className="stack">
              {wizards.map(w => (
                <WizardDomainSetup
                  key={w.id}
                  wizard={w}
                  updateWizardDomains={updateWizardDomains}
                  removeWizard={removeWizard}
                />
              ))}
            </div>
          )}

          {wizards.length >= 2 && (
            <div style={{ marginTop: '1.5rem' }}>
              <button
                className={canStart ? 'btn-success' : 'btn-secondary'}
                disabled={!canStart}
                onClick={() => canStart && startTrial()}
                style={{ width: '100%', opacity: canStart ? 1 : 0.7 }}
              >
                {canStart ? TEXT.startGameButton : TEXT.startGameRequirement}
              </button>
              {!canStart && (
                <div className="note" style={{ marginTop: '0.75rem' }}>
                  Ensure every wizard has at least 1 power in any domain.
                </div>
              )}
            </div>
          )}
        </div>
      );
    }

    // -------------------------------------------------------------------------
    // Voting/Allocation Phase
    // -------------------------------------------------------------------------
    function VotingPhase({ wizards, onFinishVoting }) {
      const playerCount = wizards.length;
      const availableTrials = config.trials.filter(t => !t.minPlayers || t.minPlayers <= playerCount);
      const recognitionTable = config.recognitionPoints[playerCount] || {};

      const [allocations, setAllocations] = useState(() => {
        const initial = {};
        wizards.forEach(w => {
          initial[w.id] = {};
          availableTrials.forEach(trial => {
            initial[w.id][trial.id] = {};
          });
        });
        return initial;
      });
      const [locked, setLocked] = useState({});
      const [selectedWizard, setSelectedWizard] = useState(wizards[0]?.id);
      const [selectedTrial, setSelectedTrial] = useState(null);

      const wizard = wizards.find(w => w.id === selectedWizard);
      if (!wizard) return null;

      const wizardAllocations = allocations[wizard.id] || {};

      // Calculate allocated and remaining power for each domain
      const getAllocatedByDomain = () => {
        const allocated = {};
        Object.keys(wizard.domains).forEach(d => { allocated[d] = 0; });

        Object.values(wizardAllocations).forEach(trialAlloc => {
          Object.entries(trialAlloc).forEach(([domain, amount]) => {
            allocated[domain] = (allocated[domain] || 0) + amount;
          });
        });
        return allocated;
      };

      const allocatedByDomain = getAllocatedByDomain();
      const remainingByDomain = {};
      Object.entries(wizard.domains).forEach(([domain, capacity]) => {
        remainingByDomain[domain] = capacity - (allocatedByDomain[domain] || 0);
      });

      const totalRemaining = Object.values(remainingByDomain).reduce((sum, v) => sum + v, 0);

      const updateAllocation = (trialId, domain, value) => {
        const val = Math.max(0, parseInt(value) || 0);
        setAllocations(prev => ({
          ...prev,
          [wizard.id]: {
            ...prev[wizard.id],
            [trialId]: {
              ...prev[wizard.id][trialId],
              [domain]: val
            }
          }
        }));
      };

      const clearTrial = (trialId) => {
        setAllocations(prev => ({
          ...prev,
          [wizard.id]: {
            ...prev[wizard.id],
            [trialId]: {}
          }
        }));
      };

      const toggleLock = () => {
        setLocked(prev => ({ ...prev, [wizard.id]: !prev[wizard.id] }));
      };

      const allLocked = wizards.every(w => locked[w.id]);

      // Get validation feedback for trial
      const getValidationFeedback = (trial, trialAlloc) => {
        const domainsUsed = Object.keys(trialAlloc).filter(d => (trialAlloc[d] || 0) > 0 && d !== 'wilds');
        const elementalDomains = ['earth', 'fire', 'water', 'air'];
        const elementalDomainsUsed = domainsUsed.filter(d => elementalDomains.includes(d));
        const total = Object.values(trialAlloc).reduce((sum, v) => sum + v, 0);

        if (total === 0) return null;

        const isValid = trial.isValidAllocation(domainsUsed, elementalDomainsUsed);

        if (isValid) {
          return { type: 'valid', message: `‚úì Valid allocation ‚Ä¢ Total Power: ${total}` };
        } else {
          return { type: 'error', message: `‚úó Invalid: This allocation doesn't meet the trial requirements` };
        }
      };

      return (
        <div className="stack">
          <div className="card">
            <div className="row between wrap" style={{ marginBottom: '1rem' }}>
              <h2>Power Allocation</h2>
              {allLocked && (
                <button
                  className="btn-success"
                  onClick={() => onFinishVoting(allocations)}
                  style={{ padding: '0.75rem 1.5rem' }}
                >
                  üèÜ Reveal Results
                </button>
              )}
            </div>
            <p className="subtitle">Secretly allocate your domain power to the trials</p>

            {/* Wizard selector buttons */}
            <div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1.5rem' }}>
              {wizards.map(w => (
                <button
                  key={w.id}
                  onClick={() => setSelectedWizard(w.id)}
                  className={w.id === selectedWizard ? 'btn-primary' : locked[w.id] ? 'btn-success' : 'btn-secondary'}
                  style={{ padding: '0.5rem 1rem', fontSize: '0.9rem' }}
                >
                  {w.name} {locked[w.id] ? 'üîí' : ''}
                </button>
              ))}
            </div>
          </div>

          {/* Wizard Power Reference Table */}
          <div className="card" style={{ overflowX: 'auto' }}>
            <h4>Wizard Domain Power Reference</h4>
            <table style={{ width: '100%', marginTop: '1rem', minWidth: '600px' }}>
              <thead>
                <tr style={{ borderBottom: '2px solid var(--border)' }}>
                  <th style={{ padding: '0.75rem', textAlign: 'left' }}>Wizard</th>
                  {Object.entries(DOMAIN_NAMES).map(([key, name]) => (
                    <th key={key} style={{ padding: '0.75rem', textAlign: 'center', fontSize: '0.85rem' }}>{name}</th>
                  ))}
                  <th style={{ padding: '0.75rem', textAlign: 'center' }}>Total</th>
                </tr>
              </thead>
              <tbody>
                {wizards.map(w => (
                  <tr
                    key={w.id}
                    style={{
                      borderBottom: '1px solid var(--border)',
                      background: w.id === selectedWizard ? 'var(--card-bg-hover)' : 'transparent'
                    }}
                  >
                    <td style={{ padding: '0.75rem', fontWeight: 600 }}>
                      {w.name} {locked[w.id] && 'üîí'}
                    </td>
                    {Object.keys(DOMAIN_NAMES).map(domainKey => (
                      <td key={domainKey} style={{ padding: '0.75rem', textAlign: 'center' }}>
                        {w.domains[domainKey] || 0}
                      </td>
                    ))}
                    <td style={{ padding: '0.75rem', textAlign: 'center', fontWeight: 700 }}>
                      {Object.values(w.domains).reduce((sum, v) => sum + v, 0)}
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>

          {/* Current Wizard Allocation */}
          <div className="grid" style={{ gridTemplateColumns: locked[wizard.id] ? '1fr' : '1fr 1fr', gap: '1.5rem' }}>
            {/* Left column: Remaining Power & Trial Selection */}
            <div className="stack">
              {locked[wizard.id] && (
                <div className="warning-box">
                  <strong>Locked:</strong> Unlock to make changes
                </div>
              )}

              {/* Remaining Power */}
              <div className="card">
                <h4>Remaining Power</h4>
                <div className="domain-grid" style={{ marginTop: '0.75rem' }}>
                  {Object.entries(wizard.domains).map(([domain, capacity]) => {
                    const remaining = remainingByDomain[domain] || 0;
                    return (
                      <div key={domain} className="domain-item">
                        <div style={{ textAlign: 'center' }}>
                          <div className="small muted">{DOMAIN_NAMES[domain] || domain}</div>
                          <div className="highlight" style={{ fontSize: '1.5rem', fontWeight: 700, marginTop: '0.25rem' }}>
                            <span style={{ color: remaining === 0 ? 'var(--text-dim)' : undefined }}>
                              {remaining}
                            </span>
                            <span className="small muted"> / {capacity}</span>
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* Lock/Unlock Button */}
              <button
                className={locked[wizard.id] ? 'btn-danger' : 'btn-success'}
                onClick={toggleLock}
                style={{ width: '100%', padding: '1rem' }}
              >
                {locked[wizard.id] ? 'üîì Unlock Allocations' : 'üîí Lock In Allocations'}
              </button>

              {/* Trial Selection */}
              {!locked[wizard.id] && (
                <div className="card">
                  <h4>Select Trial to Allocate Power</h4>
                  <div className="stack" style={{ marginTop: '1rem' }}>
                    {availableTrials.map(trial => {
                      const trialAlloc = wizardAllocations[trial.id] || {};
                      const trialTotal = Object.values(trialAlloc).reduce((sum, v) => sum + v, 0);
                      const feedback = getValidationFeedback(trial, trialAlloc);
                      const rp = recognitionTable[trial.id] || {};
                      const rpText = playerCount >= 6
                        ? `${rp[1] || 0}/${rp[2] || 0} RP`
                        : `${rp[1] || 0} RP`;

                      return (
                        <button
                          key={trial.id}
                          onClick={() => setSelectedTrial(trial.id)}
                          className={selectedTrial === trial.id ? 'btn-primary' : 'btn-secondary'}
                          style={{
                            width: '100%',
                            textAlign: 'left',
                            padding: '1rem',
                            border: feedback?.type === 'valid' ? '2px solid rgba(34, 197, 94, 0.5)' : undefined,
                            background: feedback?.type === 'valid' ? 'rgba(34, 197, 94, 0.1)' : undefined
                          }}
                        >
                          <div className="row between" style={{ marginBottom: '0.5rem' }}>
                            <strong>{trial.name}</strong>
                            <span className="pill" style={{ fontSize: '0.75rem', padding: '0.25rem 0.5rem' }}>{rpText}</span>
                          </div>
                          <div className="small muted">{trial.description}</div>
                          {trialTotal > 0 && (
                            <div style={{ marginTop: '0.5rem' }}>
                              <span className="highlight" style={{ fontSize: '0.9rem' }}>
                                Total: {trialTotal}
                              </span>
                            </div>
                          )}
                        </button>
                      );
                    })}
                  </div>
                </div>
              )}

              {totalRemaining > 0 && !locked[wizard.id] && (
                <div className="note">
                  <strong>Note:</strong> You have {totalRemaining} unallocated power remaining
                </div>
              )}
            </div>

            {/* Right column: Trial Allocation Details */}
            {selectedTrial && !locked[wizard.id] && (
              <div className="card">
                {(() => {
                  const trial = availableTrials.find(t => t.id === selectedTrial);
                  if (!trial) return null;

                  const trialAlloc = wizardAllocations[trial.id] || {};
                  const feedback = getValidationFeedback(trial, trialAlloc);

                  return (
                    <>
                      <div className="row between wrap">
                        <h4>{trial.name}</h4>
                        <button
                          className="btn-danger"
                          onClick={() => clearTrial(trial.id)}
                          style={{ minWidth: '80px' }}
                        >
                          Clear
                        </button>
                      </div>

                      <p className="small muted" style={{ marginTop: '0.5rem' }}>{trial.description}</p>

                      {feedback && (
                        <div
                          className={feedback.type === 'valid' ? 'info-box' : 'warning-box'}
                          style={{
                            marginTop: '1rem',
                            background: feedback.type === 'valid' ? 'rgba(34, 197, 94, 0.15)' : undefined,
                            border: feedback.type === 'valid' ? '1px solid rgba(34, 197, 94, 0.4)' : undefined
                          }}
                        >
                          {feedback.message}
                        </div>
                      )}

                      <div className="domain-grid" style={{ marginTop: '1rem' }}>
                        {Object.entries(wizard.domains).map(([domain, capacity]) => {
                          const currentAlloc = trialAlloc[domain] || 0;
                          const remaining = remainingByDomain[domain] || 0;
                          const maxAllowable = remaining + currentAlloc;
                          const isWild = domain === 'wilds';
                          const hasRegularPower = Object.entries(trialAlloc).some(([d, v]) => d !== 'wilds' && v > 0);

                          return (
                            <div key={domain} className="domain-item">
                              <div className="field">
                                <label className="small">{DOMAIN_NAMES[domain] || domain}</label>
                                {isWild && !hasRegularPower && (
                                  <p className="small muted" style={{ fontSize: '0.7rem', marginBottom: '0.25rem', fontStyle: 'italic' }}>
                                    Add regular power first
                                  </p>
                                )}
                                <input
                                  type="number"
                                  min="0"
                                  max={maxAllowable}
                                  value={currentAlloc}
                                  onChange={(e) => updateAllocation(trial.id, domain, e.target.value)}
                                  disabled={isWild && !hasRegularPower}
                                  title={isWild && !hasRegularPower ? 'Add regular power first' : ''}
                                  style={{
                                    opacity: isWild && !hasRegularPower ? 0.5 : 1,
                                    cursor: isWild && !hasRegularPower ? 'not-allowed' : 'text'
                                  }}
                                />
                                <div className="small muted" style={{ marginTop: '0.25rem', fontSize: '0.75rem' }}>
                                  Available: {maxAllowable}
                                </div>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    </>
                  );
                })()}
              </div>
            )}
          </div>
        </div>
      );
    }

    // -------------------------------------------------------------------------
    // Results Phase
    // -------------------------------------------------------------------------
    function ResultsPhase({ wizards, allocations }) {
      const playerCount = wizards.length;
      const availableTrials = config.trials.filter(t => !t.minPlayers || t.minPlayers <= playerCount);
      const recognitionTable = config.recognitionPoints[playerCount] || {};

      // Calculate results for each trial
      const calculateTrialResults = (trial) => {
        const attempts = [];

        wizards.forEach(wizard => {
          const wizardAlloc = allocations[wizard.id]?.[trial.id] || {};
          const domainsUsed = Object.keys(wizardAlloc).filter(d => (wizardAlloc[d] || 0) > 0 && d !== 'wilds');
          const elementalDomains = ['earth', 'fire', 'water', 'air'];
          const elementalDomainsUsed = domainsUsed.filter(d => elementalDomains.includes(d));

          const isValid = trial.isValidAllocation(domainsUsed, elementalDomainsUsed);
          if (!isValid) return;

          // Calculate total power (including wild magic)
          const totalPower = Object.values(wizardAlloc).reduce((sum, v) => sum + v, 0);
          if (totalPower === 0) return;

          // Calculate tie-breakers
          const powerFromUsedDomains = domainsUsed.reduce((sum, d) => sum + (wizardAlloc[d] || 0), 0);
          const capacityOfUsedDomains = domainsUsed.reduce((sum, d) => sum + (wizard.domains[d] || 0), 0);
          const utilization = capacityOfUsedDomains > 0 ? powerFromUsedDomains / capacityOfUsedDomains : 0;

          const totalCapacity = Object.values(wizard.domains).reduce((sum, v) => sum + v, 0);
          const focus = totalCapacity > 0 ? powerFromUsedDomains / totalCapacity : 0;

          const breadth = domainsUsed.length;

          attempts.push({
            wizardId: wizard.id,
            wizardName: wizard.name,
            totalPower,
            utilization,
            focus,
            breadth,
            allocation: wizardAlloc,
            domainsUsed
          });
        });

        // Sort by: totalPower desc, utilization desc, focus desc, breadth desc
        attempts.sort((a, b) => {
          if (b.totalPower !== a.totalPower) return b.totalPower - a.totalPower;
          if (b.utilization !== a.utilization) return b.utilization - a.utilization;
          if (b.focus !== a.focus) return b.focus - a.focus;
          if (trial.usesBreadthTiebreaker && b.breadth !== a.breadth) return b.breadth - a.breadth;
          return 0;
        });

        // Assign places
        const results = [];
        let currentPlace = 1;
        for (let i = 0; i < attempts.length; i++) {
          const attempt = attempts[i];
          if (i > 0) {
            const prev = attempts[i - 1];
            const tied = prev.totalPower === attempt.totalPower &&
                         prev.utilization === attempt.utilization &&
                         prev.focus === attempt.focus &&
                         (!trial.usesBreadthTiebreaker || prev.breadth === attempt.breadth);
            if (!tied) currentPlace = i + 1;
          }
          results.push({ ...attempt, place: currentPlace });
        }

        return results;
      };

      // Calculate all trial results
      const trialResults = {};
      availableTrials.forEach(trial => {
        trialResults[trial.id] = calculateTrialResults(trial);
      });

      // Calculate recognition points for each wizard
      const wizardRP = {};
      wizards.forEach(w => { wizardRP[w.id] = 0; });

      Object.entries(trialResults).forEach(([trialId, results]) => {
        if (!results || results.length === 0) return;
        const rpForTrial = recognitionTable[trialId] || {};
        results.forEach(result => {
          const rp = rpForTrial[result.place] || 0;
          wizardRP[result.wizardId] = (wizardRP[result.wizardId] || 0) + rp;
        });
      });

      // Sort wizards by total RP
      const finalStandings = wizards.map(w => ({
        ...w,
        totalRP: wizardRP[w.id] || 0
      })).sort((a, b) => b.totalRP - a.totalRP);

      return (
        <div className="stack">
          <div className="card">
            <h2>üèÜ Ascension Trial Results</h2>
            <p className="subtitle">Recognition Points Awarded</p>
          </div>

          {availableTrials.map(trial => {
            const results = trialResults[trial.id] || [];
            const rpForTrial = recognitionTable[trial.id] || {};

            return (
              <div key={trial.id} className="card">
                <h3>{trial.name}</h3>
                <p className="small muted">{trial.description}</p>

                {results.length === 0 ? (
                  <p className="muted" style={{ marginTop: '1rem' }}>No valid attempts</p>
                ) : (
                  <div className="stack" style={{ marginTop: '1rem' }}>
                    {results.map((result, idx) => {
                      const rp = rpForTrial[result.place] || 0;
                      const isWinner = result.place === 1;

                      return (
                        <div
                          key={result.wizardId}
                          className="info-box"
                          style={{
                            background: isWinner ? 'rgba(234, 179, 8, 0.15)' : undefined,
                            border: isWinner ? '2px solid rgba(234, 179, 8, 0.5)' : undefined
                          }}
                        >
                          <div className="row between wrap">
                            <div>
                              <h4 style={{ marginBottom: '0.25rem' }}>
                                {isWinner && 'üëë '}
                                {result.wizardName}
                                {result.place <= 2 && playerCount >= 6 && ` (${result.place === 1 ? '1st' : '2nd'})`}
                              </h4>
                              <div className="pill">Total Power: {result.totalPower}</div>
                            </div>
                            {rp > 0 && (
                              <div className="highlight" style={{ fontSize: '1.5rem', fontWeight: 700 }}>
                                +{rp} RP
                              </div>
                            )}
                          </div>

                          <div className="domain-grid" style={{ marginTop: '0.75rem' }}>
                            {Object.entries(result.allocation).map(([domain, power]) => {
                              if (power === 0) return null;
                              return (
                                <div key={domain} className="domain-item">
                                  <div className="row between">
                                    <span className="small muted">{DOMAIN_NAMES[domain] || domain}</span>
                                    <span>{power}</span>
                                  </div>
                                </div>
                              );
                            })}
                          </div>

                          {idx > 0 && (
                            <p className="small muted" style={{ marginTop: '0.5rem' }}>
                              Utilization: {(result.utilization * 100).toFixed(1)}% ‚Ä¢ Focus: {(result.focus * 100).toFixed(1)}%
                              {trial.usesBreadthTiebreaker && ` ‚Ä¢ Sources: ${result.breadth}`}
                            </p>
                          )}
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>
            );
          })}

          <div className="card">
            <h2>Final Standings</h2>
            <div className="stack" style={{ marginTop: '1rem' }}>
              {finalStandings.map((wizard, idx) => (
                <div
                  key={wizard.id}
                  className="wizard-card"
                  style={{
                    background: idx === 0 ? 'rgba(234, 179, 8, 0.15)' : undefined,
                    border: idx === 0 ? '2px solid rgba(234, 179, 8, 0.5)' : undefined
                  }}
                >
                  <div className="row between">
                    <h3>{idx === 0 && 'üèÜ '}{wizard.name}</h3>
                    <div className="highlight" style={{ fontSize: '2rem', fontWeight: 700 }}>
                      {wizard.totalRP} RP
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      );
    }

    // -------------------------------------------------------------------------
    // Main App (dark-only, mobile friendly)
    // -------------------------------------------------------------------------
    function ArchmageAscensionApp() {
      const [gameState, setGameState] = useState('setup');
      const [wizards, setWizards] = useState([]);
      const [allocations, setAllocations] = useState({});

      const startTrial = () => {
        setGameState('voting');
      };

      const finishVoting = (finalAllocations) => {
        setAllocations(finalAllocations);
        setGameState('results');
      };

      const resetGame = () => {
        setGameState('setup');
        setWizards([]);
        setAllocations({});
      };

      return (
        <div className="container app-shell">
          <header>
            <h1>{TEXT.gameName}</h1>
            <div className="subtitle">{TEXT.gameSubtitle}</div>
          </header>

          {gameState === 'setup' && (
            <SetupPhase wizards={wizards} setWizards={setWizards} startTrial={startTrial} />
          )}

          {gameState === 'voting' && (
            <VotingPhase wizards={wizards} onFinishVoting={finishVoting} />
          )}

          {gameState === 'results' && (
            <ResultsPhase wizards={wizards} allocations={allocations} />
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ArchmageAscensionApp />);
  </script>
</body>
</html>
