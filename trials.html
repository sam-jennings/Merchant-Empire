<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Archmage Ascension - The Ascension Trial</title>

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Cormorant+Garamond:wght@300;400;500;600&display=swap" rel="stylesheet">

  <!-- Archmage theme (dark-only) -->
  <link rel="stylesheet" href="archmage-theme.css" />

  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Load configuration (colors/theme optional; app will not rely on it) -->
  <script src="config.js"></script>

  <style>
    /* Small, page-specific helpers (kept minimal; main theme is in archmage-theme.css) */
    .app-shell { padding-top: 1rem; padding-bottom: 2rem; }

    .stack { display: flex; flex-direction: column; gap: 1rem; }

    .row { display: flex; gap: 1rem; align-items: center; }
    .row.wrap { flex-wrap: wrap; }
    .row.between { justify-content: space-between; }

    .field { display: flex; flex-direction: column; gap: 0.35rem; }
    .field label { font-family: 'Cinzel', serif; font-size: 0.9rem; color: var(--text-dim); letter-spacing: 0.06em; }

    .input-row { display: flex; gap: 0.75rem; }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.35rem 0.65rem;
      border-radius: 999px;
      border: 1px solid rgba(183, 148, 246, 0.25);
      background: rgba(26, 11, 46, 0.35);
      color: var(--text-dim);
      font-size: 0.95rem;
      white-space: nowrap;
    }

    .icon-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 42px;
      height: 42px;
      border-radius: 10px;
      border: 1px solid rgba(183, 148, 246, 0.25);
      background: rgba(26, 11, 46, 0.35);
      color: var(--text);
    }
    .icon-btn:hover { border-color: rgba(246, 201, 74, 0.6); transform: translateY(-1px); }

    .spell-actions { display: flex; flex-wrap: wrap; gap: 0.5rem; }

    .spell-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; }
    @media (max-width: 520px) {
      .input-row { flex-direction: column; }
      .spell-grid { grid-template-columns: 1fr; }
    }

    .divider { height: 1px; background: rgba(183, 148, 246, 0.18); margin: 1rem 0; }

    .muted { color: var(--text-dim); }
    .small { font-size: 0.95rem; }

    .table-wrap { width: 100%; overflow-x: auto; -webkit-overflow-scrolling: touch; }
    .table-wrap table { min-width: 560px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useState } = React;
    const config = (typeof GameConfig !== 'undefined') ? GameConfig : {};

    // -------------------------------------------------------------------------
    // Safe config helpers (so config.colors / theme blocks can be deleted)
    // -------------------------------------------------------------------------
    const safeArray = (v) => Array.isArray(v) ? v : [];
    const safeObj = (v) => (v && typeof v === 'object') ? v : {};

    const ELEMENTS = safeArray(config.elements);
    const DOMAINS = safeObj(config.domains);
    const SPELL_TYPES = safeArray(config.spellTypes);

    const calcPower = (size) => {
      if (typeof config.calculatePower === 'function') return config.calculatePower(size);
      // Fallback: matches the current config.js behaviour
      if (size <= 4) return size * 1;
      if (size <= 6) return Math.round(size * 1.5);
      return size * 2;
    };

    const getPowerBreakdown = (size) => {
      if (typeof config.getPowerBreakdown === 'function') return config.getPowerBreakdown(size, calcPower);
      const power = calcPower(size);
      if (size <= 4) return `${size} × 1 = ${power}`;
      if (size <= 6) return `${size} × 1.5 = ${power}`;
      return `${size} × 2 = ${power}`;
    };

    const TEXT = {
      gameName: config.gameName || 'Archmage Ascension',
      gameSubtitle: config.gameSubtitle || 'The Ascension Trial',
      pointsName: config.pointsName || 'Recognition Points',
      pointsAbbreviation: config.pointsAbbreviation || 'RP',

      playerNoun: (config.text && config.text.playerNoun) || 'Wizard',
      playerNounPlural: (config.text && config.text.playerNounPlural) || 'Wizards',
      addPlayerButton: (config.text && config.text.addPlayerButton) || 'Add Wizard',
      playerInputPlaceholder: (config.text && config.text.playerInputPlaceholder) || 'Wizard name',
      startGameButton: (config.text && config.text.startGameButton) || 'Start Ascension Trial',
      startGameRequirement: (config.text && config.text.startGameRequirement) || 'All wizards must enter at least one power point',

      calculatorButton: (config.text && config.text.calculatorButton) || 'Spell Calculator',
      manualEntryActive: (config.text && config.text.manualEntryActive) || '✓ Using Manual Entry',
      switchToManual: (config.text && config.text.switchToManual) || 'Switch to Manual Entry',

      setupHeader: (config.text && config.text.setupHeader) || 'Game Setup',
      setupSubheader: (config.text && config.text.setupSubheader) || 'Calculate or Enter Domain Power',
      addPlayersHeader: (config.text && config.text.addPlayersHeader) || 'Add Wizards',

      removeButton: (config.text && config.text.removeButton) || 'Remove',
    };

    const ELEMENT_SYMBOLS = Object.fromEntries(ELEMENTS.map(e => [e.name, e.symbol]));
    const DOMAIN_NAMES = Object.fromEntries(Object.entries(DOMAINS).map(([k, v]) => [k, v.name]));

    // -------------------------------------------------------------------------
    // Icons (inline SVGs)
    // -------------------------------------------------------------------------
    const CalculatorIcon = ({ size = 20 }) => (
      <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 7h6m0 10v-3m-3 3h.01M9 17h.01M9 14h.01M12 14h.01M15 11h.01M12 11h.01M9 11h.01M7 21h10a2 2 0 002-2V5a2 2 0 00-2-2H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
      </svg>
    );

    const PlusIcon = ({ size = 18 }) => (
      <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
      </svg>
    );

    const TrashIcon = ({ size = 18 }) => (
      <svg width={size} height={size} fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
      </svg>
    );

    // -------------------------------------------------------------------------
    // Spell Calculator
    // -------------------------------------------------------------------------
    function SpellCalculator({ onDomainsCalculated }) {
      const [spells, setSpells] = useState([]);
      const [open, setOpen] = useState(true);

      const addSpell = (typeId) => {
        const defaultElementName = ELEMENTS[0]?.name || 'Earth';
        setSpells(prev => [
          ...prev,
          { id: Date.now() + Math.random(), type: typeId, element: defaultElementName, size: 3 }
        ]);
      };

      const updateSpell = (id, field, value) => {
        setSpells(prev => prev.map(s => (s.id === id ? { ...s, [field]: value } : s)));
      };

      const removeSpell = (id) => setSpells(prev => prev.filter(s => s.id !== id));

      const calculatedDomains = useMemo(() => {
        const domains = {};
        Object.keys(DOMAINS).forEach(k => (domains[k] = 0));

        for (const spell of spells) {
          const st = SPELL_TYPES.find(x => x.id === spell.type);
          if (st && typeof st.contributeToDomains === 'function') {
            st.contributeToDomains(spell, domains, calcPower);
          }
        }
        return domains;
      }, [spells]);

      useEffect(() => {
        onDomainsCalculated(calculatedDomains);
      }, [calculatedDomains]);

      const getSpellWarning = (spell) => {
        const st = SPELL_TYPES.find(x => x.id === spell.type);
        if (!st) return null;
        if (typeof st.warnUnder === 'number' && spell.size < st.warnUnder) {
          return `${st.name} needs at least ${st.warnUnder} components.`;
        }
        if (typeof st.warnOver === 'number' && spell.size > st.warnOver) {
          return `${st.name} typically doesn't exceed ${st.warnOver} components.`;
        }
        return null;
      };

      const getContributionText = (spell) => {
        const st = SPELL_TYPES.find(x => x.id === spell.type);
        if (!st || typeof st.contributeToDomains !== 'function') return '';
        const temp = {};
        Object.keys(DOMAINS).forEach(k => (temp[k] = 0));
        st.contributeToDomains(spell, temp, calcPower);
        const parts = [];
        for (const [k, v] of Object.entries(temp)) {
          if (v > 0) parts.push(`${DOMAIN_NAMES[k] || k}: +${v}`);
        }
        return parts.join(' • ');
      };

      return (
        <div className="stack">
          <button className="btn-primary" onClick={() => setOpen(o => !o)}>
            <span style={{ display: 'inline-flex', alignItems: 'center', gap: '0.6rem' }}>
              <CalculatorIcon />
              {open ? 'Hide' : 'Show'} {TEXT.calculatorButton}
            </span>
          </button>

          {open && (
            <div className="card">
              <div className="stack">
                <div>
                  <h4>Enter Your Spells</h4>
                  <p className="muted small">
                    Formula: {config.powerFormulaDescription || '3-4 ×1, 5-6 ×1.5, 7+ ×2'}
                  </p>
                </div>

                <div className="spell-actions">
                  {SPELL_TYPES.map(st => (
                    <button key={st.id} className="btn-secondary" onClick={() => addSpell(st.id)}>
                      <span style={{ display: 'inline-flex', alignItems: 'center', gap: '0.5rem' }}>
                        <PlusIcon />
                        {st.emoji ? `${st.emoji} ` : ''}{st.name}
                      </span>
                    </button>
                  ))}
                </div>

                {spells.length === 0 ? (
                  <div className="info-box">
                    <p className="muted">No spells added yet. Use the buttons above.</p>
                  </div>
                ) : (
                  <div className="stack">
                    {spells.map(spell => {
                      const st = SPELL_TYPES.find(x => x.id === spell.type);
                      const needsElement = !!st?.requiresElement;
                      const warning = getSpellWarning(spell);
                      return (
                        <div key={spell.id} className="spell-card">
                          <div className="row between wrap">
                            <div>
                              <h5 style={{ marginBottom: '0.25rem' }}>{st?.emoji ? `${st.emoji} ` : ''}{st?.name || spell.type}</h5>
                              <div className="pill" title="Power breakdown">
                                {getPowerBreakdown(spell.size)}
                              </div>
                            </div>
                            <button className="icon-btn" onClick={() => removeSpell(spell.id)} title="Remove spell">
                              <TrashIcon />
                            </button>
                          </div>

                          {warning && (
                            <div className="warning-box" style={{ marginTop: '0.75rem' }}>
                              <strong>Warning:</strong> {warning}
                            </div>
                          )}

                          <div className="spell-grid" style={{ marginTop: '0.75rem' }}>
                            {needsElement && (
                              <div className="field">
                                <label>Element</label>
                                <select value={spell.element} onChange={(e) => updateSpell(spell.id, 'element', e.target.value)}>
                                  {ELEMENTS.map(el => (
                                    <option key={el.id} value={el.name}>{(el.symbol || '')} {el.name}</option>
                                  ))}
                                </select>
                              </div>
                            )}
                            <div className="field">
                              <label>Size</label>
                              <input
                                type="number"
                                min="0"
                                value={spell.size}
                                onChange={(e) => updateSpell(spell.id, 'size', Math.max(0, parseInt(e.target.value || '0', 10)))}
                              />
                            </div>
                          </div>

                          <div className="divider" />
                          <p className="muted small"><strong>Contributes:</strong> {getContributionText(spell) || '—'}</p>
                        </div>
                      );
                    })}
                  </div>
                )}

                <div className="power-summary">
                  <h4 className="text-center" style={{ marginBottom: '1rem' }}>Calculated Total Power</h4>
                  <div className="domain-grid">
                    {Object.entries(calculatedDomains).map(([k, v]) => (
                      <div key={k} className="domain-item">
                        <div className="row between">
                          <span className="muted small">{DOMAIN_NAMES[k] || k}</span>
                          <span className="highlight">{v}</span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    // -------------------------------------------------------------------------
    // Wizard Domain Setup
    // -------------------------------------------------------------------------
    function WizardDomainSetup({ wizard, updateWizardDomains, removeWizard }) {
      const [manual, setManual] = useState(false);
      const [manualDomains, setManualDomains] = useState(wizard.domains);

      const totalPower = Object.values(wizard.domains).reduce((s, v) => s + v, 0);

      const handleDomainsCalculated = (domains) => {
        if (!manual) updateWizardDomains(wizard.id, domains);
      };

      const handleManualChange = (domainKey, value) => {
        const next = { ...manualDomains, [domainKey]: Math.max(0, parseInt(value || '0', 10)) };
        setManualDomains(next);
        if (manual) updateWizardDomains(wizard.id, next);
      };

      const toggleManual = () => {
        setManual(prev => {
          const next = !prev;
          if (next) updateWizardDomains(wizard.id, manualDomains);
          return next;
        });
      };

      return (
        <div className="wizard-card">
          <div className="row between wrap">
            <div>
              <h3 style={{ marginBottom: '0.25rem' }}>{wizard.name}</h3>
              <span className="pill">Total Power: <strong>{totalPower}</strong></span>
            </div>
            <button className="btn-danger" onClick={() => removeWizard(wizard.id)}>
              {TEXT.removeButton}
            </button>
          </div>

          <div className="divider" />

          {!manual && (
            <SpellCalculator onDomainsCalculated={handleDomainsCalculated} />
          )}

          <div style={{ marginTop: '1rem' }}>
            <button className={manual ? 'btn-secondary' : 'btn-primary'} onClick={toggleManual}>
              {manual ? TEXT.manualEntryActive : TEXT.switchToManual}
            </button>
          </div>

          {manual && (
            <div className="card" style={{ marginTop: '1rem' }}>
              <h4 style={{ marginBottom: '0.75rem' }}>Manual Power Entry</h4>
              <div className="domain-grid">
                {Object.entries(DOMAIN_NAMES).map(([domainKey, domainName]) => (
                  <div key={domainKey} className="domain-item">
                    <div className="field">
                      <label>{domainName}</label>
                      <input
                        type="number"
                        min="0"
                        value={manualDomains[domainKey] ?? 0}
                        onChange={(e) => handleManualChange(domainKey, e.target.value)}
                      />
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          <div className="info-box" style={{ marginTop: '1rem' }}>
            <h4 style={{ marginBottom: '0.5rem' }}>Current Power (for Trial Phase)</h4>
            <div className="domain-grid">
              {Object.entries(wizard.domains).map(([k, v]) => (
                <div key={k} className="domain-item">
                  <div className="row between">
                    <span className="muted small">{DOMAIN_NAMES[k] || k}</span>
                    <span className="highlight">{v}</span>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      );
    }

    // -------------------------------------------------------------------------
    // Setup Phase
    // -------------------------------------------------------------------------
    function SetupPhase({ wizards, setWizards }) {
      const [newWizardName, setNewWizardName] = useState('');

      const addWizard = () => {
        const name = newWizardName.trim();
        if (!name) return;
        const domains = Object.fromEntries(Object.keys(DOMAINS).map(k => [k, 0]));
        const wizard = {
          id: Date.now() + Math.random(),
          name,
          domains,
          allocations: {},
          locked: false
        };
        setWizards(prev => [wizard, ...prev]);
        setNewWizardName('');
      };

      const removeWizard = (wizardId) => {
        setWizards(prev => prev.filter(w => w.id !== wizardId));
      };

      const updateWizardDomains = (wizardId, domains) => {
        setWizards(prev => prev.map(w => (w.id === wizardId ? { ...w, domains } : w)));
      };

      const canStart = useMemo(() => {
        return wizards.length >= 2 && wizards.every(w => Object.values(w.domains).some(v => v > 0));
      }, [wizards]);

      return (
        <div className="card">
          <h2>{TEXT.setupHeader}</h2>
          <p className="subtitle" style={{ marginBottom: '1rem' }}>{TEXT.setupSubheader}</p>

          <div className="card" style={{ marginTop: '1rem' }}>
            <h4>{TEXT.addPlayersHeader}</h4>
            <div className="input-row" style={{ marginTop: '0.75rem' }}>
              <input
                type="text"
                value={newWizardName}
                onChange={(e) => setNewWizardName(e.target.value)}
                onKeyDown={(e) => { if (e.key === 'Enter') addWizard(); }}
                placeholder={TEXT.playerInputPlaceholder}
              />
              <button className="btn-primary" onClick={addWizard}>
                {TEXT.addPlayerButton}
              </button>
            </div>
            <p className="muted small" style={{ marginTop: '0.5rem' }}>
              Tip: On mobile, the button will stack under the input.
            </p>
          </div>

          {wizards.length > 0 && (
            <div style={{ marginTop: '1.25rem' }} className="stack">
              {wizards.map(w => (
                <WizardDomainSetup
                  key={w.id}
                  wizard={w}
                  updateWizardDomains={updateWizardDomains}
                  removeWizard={removeWizard}
                />
              ))}
            </div>
          )}

          {wizards.length >= 2 && (
            <div style={{ marginTop: '1.5rem' }}>
              <button className={canStart ? 'btn-success' : 'btn-secondary'} disabled={!canStart} style={{ width: '100%', opacity: canStart ? 1 : 0.7 }}>
                {canStart ? TEXT.startGameButton : TEXT.startGameRequirement}
              </button>
              {!canStart && (
                <div className="note" style={{ marginTop: '0.75rem' }}>
                  Ensure every wizard has at least 1 power in any domain.
                </div>
              )}
            </div>
          )}
        </div>
      );
    }

    // -------------------------------------------------------------------------
    // Placeholder phases (kept simple but mobile-friendly)
    // -------------------------------------------------------------------------
    function VotingPhase() {
      return (
        <div className="card">
          <h2>Power Allocation</h2>
          <p className="muted">Voting phase UI not implemented in this build.</p>
        </div>
      );
    }

    function ResultsPhase() {
      return (
        <div className="card">
          <h2>Results</h2>
          <p className="muted">Results phase UI not implemented in this build.</p>
        </div>
      );
    }

    // -------------------------------------------------------------------------
    // Main App (dark-only, mobile friendly)
    // -------------------------------------------------------------------------
    function ArchmageAscensionApp() {
      const [gameState, setGameState] = useState('setup');
      const [wizards, setWizards] = useState([]);

      return (
        <div className="container app-shell">
          <header>
            <h1>{TEXT.gameName}</h1>
            <div className="subtitle">{TEXT.gameSubtitle}</div>
          </header>

          {gameState === 'setup' && (
            <SetupPhase wizards={wizards} setWizards={setWizards} />
          )}

          {gameState === 'voting' && (
            <VotingPhase />
          )}

          {gameState === 'results' && (
            <ResultsPhase />
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<ArchmageAscensionApp />);
  </script>
</body>
</html>
